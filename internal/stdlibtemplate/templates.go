package stdlibtemplate

const routerPkgTemplate = `[{"filename":"router/handler.go","content":"package router\n\nimport \"net/http\"\n\nvar serverHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t// Enable for CORS\n\t// setCorsHeaders(w)\n\n\t// Enable for logging\n\t// logRequest(r)\n\n\tredirect(w, r)\n\n\tRouter.ServeHTTP(w, r)\n\n})\n\nvar httpTohttpsRedirectHandler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\ttarget := \"https://\" + r.Host + r.URL.Path\n\tif len(r.URL.RawQuery) \u003e 0 {\n\t\ttarget += \"?\" + r.URL.RawQuery\n\t}\n\thttp.Redirect(w, r, target, http.StatusMovedPermanently)\n\n\tRouter.ServeHTTP(w, r)\n})\n"},{"filename":"router/ocsp.go","content":"package router\n\nimport (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"sync\"\n\n\t\"golang.org/x/crypto/ocsp\"\n)\n\n// Global variable for cipher suites\nvar cipherSuitesTLS2 = []uint16{\n\ttls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n\ttls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n\ttls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,\n\ttls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n\ttls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,\n\ttls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,\n\ttls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n}\n\nvar cipherSuitesTLS3 = []uint16{\n\ttls.TLS_AES_128_GCM_SHA256,\n\ttls.TLS_AES_256_GCM_SHA384,\n\ttls.TLS_CHACHA20_POLY1305_SHA256,\n}\n\nvar activeSSLCache = newSSLCache()\n\ntype sslCache struct {\n\tsessions map[string]*tls.ClientSessionState\n\tmu       sync.RWMutex\n}\n\nfunc newSSLCache() *sslCache {\n\treturn \u0026sslCache{sessions: make(map[string]*tls.ClientSessionState)}\n}\n\nfunc (c *sslCache) Get(sessionKey string) (*tls.ClientSessionState, bool) {\n\tc.mu.RLock()\n\tdefer c.mu.RUnlock()\n\tsession, ok := c.sessions[sessionKey]\n\treturn session, ok\n}\n\nfunc (c *sslCache) Put(sessionKey string, cs *tls.ClientSessionState) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.sessions[sessionKey] = cs\n}\n\nfunc fetchOCSPResponse(cert tls.Certificate) ([]byte, *ocsp.Response, error) {\n\t// Parse the certificate\n\tx509Cert, err := x509.ParseCertificate(cert.Certificate[0])\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Check if the certificate has an OCSP server\n\tif len(x509Cert.OCSPServer) == 0 {\n\t\treturn nil, nil, errors.New(\"no OCSP server in certificate\")\n\t}\n\tx509Cert.OCSPServer[0] = \"http://r3.o.lencr.org\"\n\n\t// Create an OCSP request\n\tocspRequest, err := ocsp.CreateRequest(x509Cert, x509Cert, nil)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Send the OCSP request to the OCSP server\n\tresp, err := http.Post(x509Cert.OCSPServer[0], \"application/ocsp-request\", bytes.NewReader(ocspRequest))\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\t// Check the HTTP response status\n\tif resp.StatusCode != http.StatusOK {\n\t\treturn nil, nil, fmt.Errorf(\"OCSP server returned status %d\", resp.StatusCode)\n\t}\n\n\t// Read the OCSP response\n\tocspResponseBytes, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Parse the OCSP response\n\tocspResponse, err := ocsp.ParseResponse(ocspResponseBytes, nil)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn ocspResponseBytes, ocspResponse, nil\n}\n\nfunc orderProtos(protos []string) []string {\n\tfor _, proto := range protos {\n\t\tif proto == \"h3\" {\n\t\t\treturn protos\n\t\t}\n\t}\n\n\t// If \"h3\" is not found, append \"h3\" and \"h3-29\"\n\treturn append(protos, \"h3\", \"h3-29\")\n}\n"},{"filename":"router/redirects.go","content":"package router\n\nimport \"net/http\"\n\nvar Redirects = map[string]string{\n\t\"/\": \"/index.html\",\n}\n\nfunc redirect(w http.ResponseWriter, r *http.Request) {\n\tredir, ok := Redirects[r.URL.Path]\n\tif ok {\n\t\thttp.Redirect(w, r, redir, http.StatusMovedPermanently)\n\t}\n}\n"},{"filename":"router/router.go","content":"package router\n\nimport \"net/http\"\n\nvar Router = http.NewServeMux()\n"},{"filename":"router/serve.go","content":"package router\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/quic-go/quic-go\"\n\t\"github.com/quic-go/quic-go/http3\"\n\t\"golang.org/x/net/http2\"\n)\n\ntype ServerControl struct {\n\tstart chan bool\n}\n\n//var TLSCerts = []tls.Certificate{certs}\n\n// Quic config\nvar quicConfig = \u0026quic.Config{\n\tMaxIdleTimeout:          10 * time.Minute,\n\tMaxIncomingStreams:      1000,\n\tMaxIncomingUniStreams:   1000,\n\tAllow0RTT:               true,\n\tDisablePathMTUDiscovery: false,\n}\n\n// TLS config\nfunc getTLSConfig(certs []tls.Certificate, baseTLSConfig *tls.Config) *tls.Config {\n\treturn \u0026tls.Config{\n\n\t\tGetConfigForClient: func(chi *tls.ClientHelloInfo) (*tls.Config, error) {\n\t\t\tconfig := \u0026tls.Config{\n\t\t\t\tCertificates:                certs,\n\t\t\t\tClientSessionCache:          baseTLSConfig.ClientSessionCache,\n\t\t\t\tDynamicRecordSizingDisabled: baseTLSConfig.DynamicRecordSizingDisabled,\n\t\t\t\tMinVersion:                  tls.VersionTLS12,\n\t\t\t\tServerName:                  baseTLSConfig.ServerName,\n\t\t\t\tNextProtos:                  orderProtos(chi.SupportedProtos),\n\t\t\t}\n\t\t\tif len(chi.SupportedVersions) \u003e 0 {\n\t\t\t\thighestVersion := chi.SupportedVersions[0]\n\t\t\t\tif highestVersion == tls.VersionTLS13 {\n\t\t\t\t\t// Set cipher suites for TLS 1.3\n\t\t\t\t\tconfig.CipherSuites = cipherSuitesTLS3\n\t\t\t\t} else {\n\t\t\t\t\t// Set cipher suites for TLS 1.2\n\t\t\t\t\tconfig.CipherSuites = cipherSuitesTLS2\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn config, nil\n\t\t},\n\t}\n}\n\n// HTTP/2 and HTTP/1.1 Server\nvar http2Server = \u0026http.Server{\n\t//Handler:     serverHandler,\n\tReadTimeout: 60 * time.Second, WriteTimeout: 60 * time.Second,\n}\n\n// HTTP/3 Server\nvar http3Server = \u0026http3.Server{\n\tQUICConfig: quicConfig,\n}\n\n// Redirect server for http to https\nvar httpRedirectSrv = \u0026http.Server{\n\tReadTimeout: 60 * time.Second, WriteTimeout: 60 * time.Second,\n}\n\nfunc ServeTLS(addr, httpOnlyAddr, certFile, keyFile string, sni string) error {\n\n\tswitch {\n\tcase addr == \"\":\n\t\treturn errors.New(\"port is required\")\n\tcase httpOnlyAddr == \"\":\n\t\treturn errors.New(\"httpOnlyPort is required\")\n\tcase certFile == \"\":\n\t\treturn errors.New(\"certFile is required\")\n\tcase keyFile == \"\":\n\t\treturn errors.New(\"keyFile is required\")\n\tcase sni == \"\":\n\t\treturn errors.New(\"sni is required\")\n\t}\n\n\thttp2Server.Addr = addr\n\thttp3Server.Addr = addr\n\thttpRedirectSrv.Addr = httpOnlyAddr\n\tcerts, err := InitTLS(keyFile, certFile)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to initialize tls: %w\", err)\n\t}\n\tbaseTLSConfig := \u0026tls.Config{\n\t\tDynamicRecordSizingDisabled: false,\n\t\tClientSessionCache:          activeSSLCache,\n\t\tServerName:                  sni,\n\t}\n\ttlsConfig := getTLSConfig(certs, baseTLSConfig)\n\thttp2Server.TLSConfig = tlsConfig\n\thttp3Server.TLSConfig = http3.ConfigureTLSConfig(tlsConfig)\n\n\thttpRedirectSrv.Addr = httpOnlyAddr\n\n\ttlsConfig.NextProtos = []string{\"h3\", \"h2\", \"http/1.1\"}\n\ttlsConfig.MinVersion = tls.VersionTLS13\n\n\t// enable/disable tracing\n\t// quicConfig.Tracer = qlog.DefaultTracer\n\n\t// Open the listeners\n\tudpAddr, err := net.ResolveUDPAddr(\"udp\", addr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to resolve udp address: %w\", err)\n\t}\n\tudpConn, err := net.ListenUDP(\"udp\", udpAddr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to listen on udp: %w\", err)\n\t}\n\tlog.Printf(\"UDP connection: %v\", udpConn)\n\t//defer udpConn.Close()\n\n\t// TCP connection\n\ttcpListener, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen on TCP: %v\", err)\n\t}\n\ttlsListener := tls.NewListener(tcpListener, tlsConfig)\n\n\t// Http to https redirect listener\n\thttponlyTcpListener, err := net.Listen(\"tcp\", httpOnlyAddr)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen on TCP: %v\", err)\n\t}\n\n\tlog.Printf(\"UDP connection: %v\", udpConn)\n\n\tcontrol := \u0026ServerControl{\n\t\tstart: make(chan bool, 10),\n\t}\n\tstart := control.start\n\n\t// Set handlers\n\thttp2Server.Handler = serverHandler\n\thttp3Server.Handler = serverHandler\n\thttpRedirectSrv.Handler = httpTohttpsRedirectHandler\n\n\tlog.Printf(\"h3 handler: %v\", http3Server.Handler)\n\tlog.Printf(\"h2 handler: %v\", http2Server.Handler)\n\n\t// Configure the http2 server\n\n\thttp2ServerConfig := \u0026http2.Server{\n\t\tIdleTimeout: 10 * time.Minute, // the amount of time a connection can be idle before it's closed\n\t\tMaxHandlers: 100,              // the maximum number of http.Handler invocations simultaneously serving requests\n\t}\n\t// The actual h2 configuration\n\terr = http2.ConfigureServer(http2Server, http2ServerConfig)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to configure http2 server: %v\", err)\n\t}\n\n\t// Run the servers\n\th2Err := make(chan error, 1)\n\th3Err := make(chan error, 1)\n\tkill := make(chan bool, 1)\n\n\t// check udpconn\n\n\tlog.Printf(\"UDP connection: %v\", udpConn)\n\n\tlog.Printf(\"Sendinig start signal\")\n\tstart \u003c- true\n\tstart \u003c- true\n\n\tgo func() {\n\t\t\u003c-start\n\n\t\tlog.Printf(\"udpConn.LocalAddr.String: %s\", udpConn.LocalAddr().String())\n\t\tlog.Printf(\"Starting server HTTP/3\")\n\n\t\th3Err \u003c- http3Server.Serve(udpConn)\n\t\t\u003c-kill\n\n\t}()\n\t// Serve HTTP/1.1 and HTTP/2 requests\n\tgo func() {\n\t\t\u003c-start\n\t\t//logger.LogTLSListener(tlsListener)\n\t\tlog.Printf(\"Serving HTTP/1.1 and HTTP/2\")\n\t\th2Err \u003c- http2Server.Serve(tlsListener)\n\t\t\u003c-kill\n\t}()\n\t// Redirect server\n\tgo func() {\n\t\tif err := httpRedirectSrv.Serve(httponlyTcpListener); err != nil \u0026\u0026 err != http.ErrServerClosed {\n\t\t\tlog.Printf(\"Could not listen on %s: %v\\n\", \":80\", err)\n\t\t}\n\t}()\n\n\t// Create a channel to listen for interrupt signals\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGINT)\n\t// Wait for an interrupt signal in a separate goroutine\n\tgo func() {\n\t\t\u003c-quit\n\n\t\tkill \u003c- true\n\t\t// Create a deadline to wait for.\n\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\n\t\thttp2Server.Shutdown(ctx)\n\t\thttp3Server.Close()\n\n\t\tlog.Print(\"Servers stopped gracefully\")\n\t}()\n\tselect {\n\tcase err := \u003c-h2Err:\n\t\treturn fmt.Errorf(\"HTTP/1.1 and HTTP/2 server failed: %w\", err)\n\tcase err := \u003c-h3Err:\n\t\treturn fmt.Errorf(\"HTTP/3 server failed: %w\", err)\n\t}\n\n}\n\nfunc InitTLS(keypath, certpath string) ([]tls.Certificate, error) {\n\tvar pemBlocks = make(map[string][]byte)\n\tvar err error\n\tvar cert tls.Certificate\n\tpemBlocks[\"cert\"], err = os.ReadFile(certpath)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to read certificate file: %v\", err)\n\t}\n\n\tpemBlocks[\"key\"], err = os.ReadFile(keypath)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to read key file: %v\", err)\n\t}\n\tcert, err = tls.X509KeyPair(pemBlocks[\"cert\"], pemBlocks[\"key\"])\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to parse certificate and key: %v\", err)\n\t}\n\n\t// Fetch the OCSP response and add it to the certificate\n\tocspResponseBytes, _, err := fetchOCSPResponse(cert)\n\tif err != nil {\n\t\tlog.Printf(\"Failed to fetch OCSP response: %v\", err)\n\t}\n\n\tcert.OCSPStaple = ocspResponseBytes\n\treturn []tls.Certificate{cert}, nil\n\n}\n\nfunc Serve(addr string) error {\n\tif addr == \"\" {\n\t\treturn errors.New(\"port is required\")\n\t}\n\n\tserver := \u0026http.Server{\n\t\tAddr:    addr,\n\t\tHandler: serverHandler,\n\t}\n\tlog.Printf(\"Starting server on http://localhost%s\\n\", addr)\n\n\ttcpListener, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to listen on TCP: %v\", err)\n\t}\n\n\terrChan := make(chan error, 1)\n\tkill := make(chan bool, 1)\n\n\tgo func() {\n\n\t\t//logger.LogTLSListener(tlsListener)\n\t\tlog.Printf(\"Serving HTTP/1.1 and HTTP/2\")\n\t\terrChan \u003c- server.Serve(tcpListener)\n\n\t}()\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, syscall.SIGINT)\n\tgo func() {\n\t\t\u003c-quit\n\n\t\tkill \u003c- true\n\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\n\t\thttp2Server.Shutdown(ctx)\n\t\thttp3Server.Close()\n\n\t\tlog.Print(\"Servers stopped gracefully\")\n\t}()\n\tselect {\n\tcase err := \u003c-errChan:\n\t\treturn fmt.Errorf(\"HTTP/1.1 and HTTP/2 server failed: %w\", err)\n\tcase \u003c-kill:\n\t\treturn nil\n\t}\n\n}\n"}]`
